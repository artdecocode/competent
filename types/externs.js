/**
 * @fileoverview
 * @externs
 */

/* typal types/exported.xml externs */
/** @const */
var _competent = {}
/**
 * An exported component.
 * @record
 */
_competent.ExportedComponent
/**
 * The name of the component as passed to _Competent_.
 * @type {string}
 */
_competent.ExportedComponent.prototype.key
/**
 * The ID where the component should render.
 * @type {string}
 */
_competent.ExportedComponent.prototype.id
/**
 * Properties of the component.
 * @type {!Object}
 */
_competent.ExportedComponent.prototype.props
/**
 * Children as strings.
 * @type {!Array<string>}
 */
_competent.ExportedComponent.prototype.children

/* typal types/index.xml externs */
/**
 * The properties extracted from HTML and to be passed to the component for rendering.
 * @typedef {Object<string, *>}
 */
_competent.Props
/**
 * Service methods for `competent`.
 * @typedef {{ export: function(boolean=): void, setPretty: function(boolean,number=): void, renderAgain: function(boolean=): void }}
 */
_competent.Meta
/**
 * Options for the program. All functions will be called with the Replaceable instance as their `this` context.
 * @record
 */
_competent.Config
/**
 * If there was an error when rendering the component, controls whether the HTML should be be left on the page.
 * @type {boolean|undefined}
 */
_competent.Config.prototype.removeOnError
/**
 * The function which returns an `id` for the html element.
 * @type {(function(): string)|undefined}
 */
_competent.Config.prototype.getId = function() {}
/**
 * The function which takes the parsed properties from HTML and competent's meta methods, and returns the properties object to be passed to the component. By default, returns the properties simply merged with _meta_.
 * @type {(function(!_competent.Props,!_competent.Meta,string): Object)|undefined}
 */
_competent.Config.prototype.getProps = function(props, meta, componentName) {}
/**
 * If the component called the `export` meta method, this function will be called at the end of the replacement rule with its key, root id, properties and children as strings.
 * @type {(function(string,string,!_competent.Props,!Array<string>): void)|undefined}
 */
_competent.Config.prototype.markExported = function(key, id, props, children) {}
/**
 * The callback at the end of a successful replacement with the component's key.
 * @type {(function(string): void)|undefined}
 */
_competent.Config.prototype.onSuccess = function(componentName) {}
/**
 * The callback at the end of failed replacement with the component's key, error object, position number and the string which was fed to the rule.
 * @type {(function(string,Error,number,string): void)|undefined}
 */
_competent.Config.prototype.onFail = function(componentName, error, position, input) {}
/**
 * The function to be called to get the properties to set on the child _Replaceable_ started to recursively replace inner HTML. This is needed if the root _Replaceable_ was assigned some properties that are referenced in components.
 * @type {(function(): !Object)|undefined}
 */
_competent.Config.prototype.getContext = function() {}
/**
 * The function which should return the list of replacements for `renderAgain` method. By default, the initial rule generated by _Competent_ is used. The first argument passed is the key, and the second argument is the value passed via the `renderAgain`, that is if the component might render recursively.
 * @type {(function(string,boolean): !Array<!_restream.Rule>)|undefined}
 */
_competent.Config.prototype.getReplacements = function(componentName, recursiveRenderAgain) {}
