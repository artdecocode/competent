<types namespace="_competent">

   <type record name="Config" desc="Options for the program. All functions will be called with the Replaceable instance as their `this` context.">
    <fn opt return="string" name="getId">
      <arg string name="key">Component key.</arg>
      <arg name="props" type="!_competent.Props">Either HTML props, or properties overriden by `.export` call.</arg>
      The function which returns an `id` for the html element.
    </fn>
    <fn opt name="getProps" return="Object">
      <arg name="props" type="!_competent.Props">Properties.</arg>
      <arg name="meta" type="!_competent.Meta">Meta properties.</arg>
      <arg string name="componentName">The name of the component.</arg>
      <arg number name="position">The position where match happened.</arg>
      The function which takes the parsed properties from HTML and competent's meta methods, and returns the properties object to be passed to the component. By default, returns the properties simply merged with _meta_.
    </fn>
    <fn opt name="markExported">
      <arg string name="key">Component key.</arg>
      <arg string name="id">
        The ID assigned manually either via the element's id attribute, or with the `getId` function automatically.
      </arg>
      <arg type="!_competent.Props" name="props">Component properties.</arg>
      <arg type="!Array<string>" name="children">Component children.</arg>
      If the component called the `export` meta method, this function will be called at the end of the replacement rule with its key, root id, properties and children as strings.
    </fn>
    <prop boolean name="removeOnError" default="false">
      If there was an error when rendering the component, controls whether the HTML should be be left on the page.
    </prop>
    <fn name="onSuccess" opt void>
      <arg string name="componentName">The element name, e.g., `my-element`.</arg>
      <arg type="!Object<string, string>" name="htmlProps">The properties with which the component was initialised.</arg>
      The callback at the end of a successful replacement with the component's key.
    </fn>
    <fn opt name="onFail" void>
      <arg string name="componentName">The element name, e.g., `my-element`.</arg>
      <arg name="error" type="!Error">The error.</arg>
      <arg number name="position">The position in the input text where element started.</arg>
      <arg string name="input">The input string.</arg>
      The callback at the end of failed replacement with the component's key, error object, position number and the string which was fed to the rule.
    </fn>
    <fn opt name="getContext" return="!Object">
      <arg opt name="childContext" type="!Object">
        The child context set by `meta.setChildContext` with `undefined` if not set.
      </arg>
      <arg type="{ position: number, key: string }" name="parent">The info about the parent component.</arg>
      The function to be called to get the properties to set on the child _Replaceable_ started to recursively replace inner HTML. This is needed if the root _Replaceable_ was assigned some properties that are referenced in components.
    </fn>
    <fn opt name="getReplacements" return="!Array<!_restream.Rule>">
      <arg string name="componentName">Component key.</arg>
      <arg boolean name="recursiveRenderAgain">The value passed to `renderAgain`.</arg>
      The function which should return the list of replacements for `renderAgain` method. By default, the initial rule generated by _Competent_ is used. The first argument passed is the key, and the second argument is the value passed via the `renderAgain`, that is if the component might render recursively.
    </fn>
  </type>

  <type type="Object<string, *>" name="Props" desc="The properties extracted from HTML and to be passed to the component for rendering.">
  </type>

  <type name="Meta" desc="Service methods for `competent`.">
    <fn name="export" void>
      <arg boolean name="shouldExport" opt>Whether to export the component. Default `true`.</arg>
      <arg type="Object" name="props" opt>Properties with which to export. If not passed, the same HTML props are used, otherwise overrides them. Undefined values will be removed.</arg>
      When called, marks the component for export and adds an `id` if the root element of the hyper result did not have it. Individual instances can pass the `false` value if they don't want to get exported.
    </fn>
    <fn name="skipRender" void>
      If this method is called, _Competent_ will return the original match without rendering the component into static HTML. This should be used together with `export` to provide run-time dynamic browser rendering, without static HTML code generation.
    </fn>
    <fn name="setPretty" void>
      <arg boolean name="isPretty">Whether to pretty print.</arg>
      <arg number name="lineLength" opt>Number of characters after which to wrap lines.</arg>
      The function which controls whether to enable pretty printing, and the line width.
    </fn>
    <fn name="removeLine" void>
      <arg boolean name="shouldRemove" opt>Sets whether the new line should be removed (default `true`).</arg>
      If the component rendered a falsy value (e.g., `null`, `''`), and the `removeLine` was called, _Competent_ will remove `\n___＜component＞`. By default, this is switched off.
    </fn>
    <fn name="renderAgain" void>
      <arg boolean name="doRender" opt>
        Whether to render component again to update its inner HTML. Default `true`.
      </arg>
      <arg boolean name="recursiveRender" opt>
        Whether to render element with the same name. Default `false`.
      </arg>
      After rendering the component itself, the children by default are also rendered by spawning another _Replaceable_ stream. This is needed when a component might contain other components when rendered.
      - When `recursiveRender` is set to false (default), the component key will be excluded from the rule to prevent recursion.
      - No recursion is allowed otherwise the program will get stuck, unless `＜img/＞` renders `＜img＞` (no `/`) for example.
      - If `getReplacements` was used to specify how to acquire the replacements for the new child _Replaceable_ stream, the `recursiveRender` arg will be pased to it.
    </fn>
    <fn name="setChildContext" void>
      <arg type="!Object" name="context">
        The context specific for children of the node that calls `renderAgain`.
      </arg>
      JSX nodes are rendered breadth-first, meaning that siblings will receive the same `this` context. If one of them modifies it, the another one will also pass the updated one to children, which is not always desirable. To create a fork context unique for children of sibling nodes, the child context can be set. It will be passed as an argument to `getContext`.
    </fn>
  </type>
</types>